CREATE TABLE person (
    id TEXT NOT NULL PRIMARY KEY,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    sex TEXT NOT NULL,
    active INTEGER NOT NULL DEFAULT 1,
    suspended INTEGER NOT NULL DEFAULT 0,
    can_assist INTEGER NOT NULL DEFAULT 0,
    CHECK(active IN (0, 1)),
    CHECK(suspended IN (0, 1)),
    CHECK(can_assist IN (0, 1))
);

CREATE UNIQUE INDEX IF NOT EXISTS person_unique_full_name_nocase
ON person(first_name COLLATE NOCASE, last_name COLLATE NOCASE);

CREATE TABLE part_type (
    id TEXT NOT NULL PRIMARY KEY,
    code TEXT NOT NULL UNIQUE,
    label TEXT NOT NULL,
    people_count INTEGER NOT NULL,
    sex_rule TEXT NOT NULL,
    fixed INTEGER NOT NULL DEFAULT 0,
    active INTEGER NOT NULL DEFAULT 1,
    sort_order INTEGER NOT NULL DEFAULT 0,
    current_revision_id TEXT DEFAULT NULL,
    CHECK(people_count >= 1),
    CHECK(fixed IN (0, 1)),
    CHECK(active IN (0, 1))
);

CREATE TABLE part_type_revision (
    id TEXT NOT NULL PRIMARY KEY,
    part_type_id TEXT NOT NULL,
    label TEXT NOT NULL,
    people_count INTEGER NOT NULL,
    sex_rule TEXT NOT NULL,
    fixed INTEGER NOT NULL DEFAULT 0,
    revision_number INTEGER NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL,
    FOREIGN KEY (part_type_id) REFERENCES part_type(id) ON DELETE CASCADE,
    CHECK(people_count >= 1),
    CHECK(fixed IN (0, 1))
);

CREATE INDEX IF NOT EXISTS part_type_revision_part_type_id_idx
ON part_type_revision(part_type_id, revision_number DESC);

CREATE TABLE program_monthly (
    id TEXT NOT NULL PRIMARY KEY,
    year INTEGER NOT NULL,
    month INTEGER NOT NULL,
    start_date TEXT NOT NULL,
    end_date TEXT NOT NULL,
    template_applied_at TEXT DEFAULT NULL,
    created_at TEXT NOT NULL,
    UNIQUE(year, month)
);

CREATE TABLE schema_week (
    id TEXT NOT NULL PRIMARY KEY,
    week_start_date TEXT NOT NULL UNIQUE
);

CREATE TABLE schema_week_part (
    id TEXT NOT NULL PRIMARY KEY,
    schema_week_id TEXT NOT NULL,
    part_type_id TEXT NOT NULL,
    sort_order INTEGER NOT NULL,
    FOREIGN KEY (schema_week_id) REFERENCES schema_week(id) ON DELETE CASCADE,
    FOREIGN KEY (part_type_id) REFERENCES part_type(id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS schema_week_part_week_id_idx
ON schema_week_part(schema_week_id);

CREATE TABLE person_part_type_eligibility (
    id TEXT NOT NULL PRIMARY KEY,
    person_id TEXT NOT NULL,
    part_type_id TEXT NOT NULL,
    can_lead INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (person_id) REFERENCES person(id) ON DELETE CASCADE,
    FOREIGN KEY (part_type_id) REFERENCES part_type(id) ON DELETE CASCADE,
    CHECK(can_lead IN (0, 1)),
    UNIQUE(person_id, part_type_id)
);

CREATE TABLE assignment_settings (
    id TEXT NOT NULL PRIMARY KEY,
    strict_cooldown INTEGER NOT NULL DEFAULT 1,
    lead_weight INTEGER NOT NULL DEFAULT 2,
    assist_weight INTEGER NOT NULL DEFAULT 1,
    lead_cooldown_weeks INTEGER NOT NULL DEFAULT 4,
    assist_cooldown_weeks INTEGER NOT NULL DEFAULT 2,
    CHECK(strict_cooldown IN (0, 1))
);

CREATE TABLE schema_update_anomaly (
    id TEXT NOT NULL PRIMARY KEY,
    person_id TEXT NOT NULL,
    part_type_id TEXT NOT NULL,
    reason TEXT NOT NULL,
    schema_version TEXT DEFAULT NULL,
    created_at TEXT NOT NULL,
    dismissed INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (person_id) REFERENCES person(id) ON DELETE CASCADE,
    FOREIGN KEY (part_type_id) REFERENCES part_type(id) ON DELETE CASCADE,
    CHECK(dismissed IN (0, 1))
);

CREATE TABLE week_plan (
    id TEXT NOT NULL PRIMARY KEY,
    week_start_date TEXT NOT NULL UNIQUE,
    program_id TEXT DEFAULT NULL,
    status TEXT NOT NULL DEFAULT 'ACTIVE',
    FOREIGN KEY (program_id) REFERENCES program_monthly(id) ON DELETE SET NULL
);

CREATE TABLE weekly_part (
    id TEXT NOT NULL PRIMARY KEY,
    week_plan_id TEXT NOT NULL,
    part_type_id TEXT NOT NULL,
    part_type_revision_id TEXT DEFAULT NULL,
    sort_order INTEGER NOT NULL,
    FOREIGN KEY (week_plan_id) REFERENCES week_plan(id) ON DELETE CASCADE,
    FOREIGN KEY (part_type_id) REFERENCES part_type(id) ON DELETE RESTRICT,
    FOREIGN KEY (part_type_revision_id) REFERENCES part_type_revision(id) ON DELETE SET NULL
);

CREATE TABLE assignment (
    id TEXT NOT NULL PRIMARY KEY,
    weekly_part_id TEXT NOT NULL,
    person_id TEXT NOT NULL,
    slot INTEGER NOT NULL,
    FOREIGN KEY (weekly_part_id) REFERENCES weekly_part(id) ON DELETE CASCADE,
    FOREIGN KEY (person_id) REFERENCES person(id) ON DELETE RESTRICT,
    CHECK(slot >= 1),
    UNIQUE(weekly_part_id, slot)
);

CREATE INDEX IF NOT EXISTS weekly_part_week_plan_id_idx
ON weekly_part(week_plan_id);

CREATE INDEX IF NOT EXISTS assignment_person_id_idx
ON assignment(person_id);

CREATE UNIQUE INDEX IF NOT EXISTS assignment_unique_part_slot
ON assignment(weekly_part_id, slot);

-- Person queries (existing)
allActiveProclaimers:
SELECT id, first_name, last_name, sex, active
FROM person
WHERE active = 1
ORDER BY last_name, first_name;

allAssignableProclaimers:
SELECT id, first_name, last_name, sex, active, suspended, can_assist
FROM person
WHERE active = 1
  AND suspended = 0
ORDER BY last_name, first_name;

searchProclaimers:
SELECT id, first_name, last_name, sex, active
FROM person
WHERE (
    ? = 1
   OR first_name LIKE '%' || ? || '%' COLLATE NOCASE
   OR last_name LIKE '%' || ? || '%' COLLATE NOCASE
   OR (first_name || ' ' || last_name) LIKE '%' || ? || '%' COLLATE NOCASE
  )
ORDER BY last_name, first_name;

findProclaimerById:
SELECT id, first_name, last_name, sex, active
FROM person
WHERE id = ?;

findProclaimerByIdExtended:
SELECT id, first_name, last_name, sex, active, suspended, can_assist
FROM person
WHERE id = ?;

countProclaimersByFullName:
SELECT COUNT(*)
FROM person
WHERE first_name = ? COLLATE NOCASE
  AND last_name = ? COLLATE NOCASE;

countProclaimersByFullNameExcludingId:
SELECT COUNT(*)
FROM person
WHERE first_name = ? COLLATE NOCASE
  AND last_name = ? COLLATE NOCASE
  AND id != ?;

upsertProclaimer:
INSERT INTO person(id, first_name, last_name, sex, active, suspended, can_assist)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    first_name = excluded.first_name,
    last_name = excluded.last_name,
    sex = excluded.sex,
    active = excluded.active,
    suspended = excluded.suspended,
    can_assist = excluded.can_assist;

deleteProclaimerById:
DELETE FROM person
WHERE id = ?;

-- Part type queries
allPartTypes:
SELECT id, code, label, people_count, sex_rule, fixed, sort_order
FROM part_type
ORDER BY sort_order, label;

findPartTypeByCode:
SELECT id, code, label, people_count, sex_rule, fixed, sort_order
FROM part_type
WHERE code = ?;

findFixedPartType:
SELECT id, code, label, people_count, sex_rule, fixed, sort_order
FROM part_type
WHERE fixed = 1
LIMIT 1;

upsertPartType:
INSERT INTO part_type(id, code, label, people_count, sex_rule, fixed, sort_order)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(code) DO UPDATE SET
    label = excluded.label,
    people_count = excluded.people_count,
    sex_rule = excluded.sex_rule,
    fixed = excluded.fixed,
    sort_order = excluded.sort_order,
    active = 1;

-- Week plan queries
findWeekPlanByDate:
SELECT id, week_start_date
FROM week_plan
WHERE week_start_date = ?;

weekPlansInRange:
SELECT id, week_start_date
FROM week_plan
WHERE week_start_date >= ? AND week_start_date <= ?
ORDER BY week_start_date;

totalSlotsByWeekInRange:
SELECT
    wpl.id AS week_plan_id,
    COALESCE(SUM(pt.people_count), 0) AS total_slots
FROM week_plan wpl
LEFT JOIN weekly_part wp ON wp.week_plan_id = wpl.id
LEFT JOIN part_type pt ON wp.part_type_id = pt.id
WHERE wpl.week_start_date >= ? AND wpl.week_start_date <= ?
GROUP BY wpl.id;

assignmentCountsByWeekInRange:
SELECT
    wpl.id AS week_plan_id,
    COUNT(a.id) AS assignment_count
FROM week_plan wpl
LEFT JOIN weekly_part wp ON wp.week_plan_id = wpl.id
LEFT JOIN assignment a ON a.weekly_part_id = wp.id
WHERE wpl.week_start_date >= ? AND wpl.week_start_date <= ?
GROUP BY wpl.id;

insertWeekPlan:
INSERT INTO week_plan(id, week_start_date)
VALUES (?, ?);

deleteWeekPlan:
DELETE FROM week_plan WHERE id = ?;

-- Weekly part queries (with JOIN to part_type)
partsForWeek:
SELECT
    wp.id,
    wp.week_plan_id,
    wp.part_type_id,
    wp.sort_order,
    pt.code AS part_type_code,
    pt.label AS part_type_label,
    pt.people_count AS part_type_people_count,
    pt.sex_rule AS part_type_sex_rule,
    pt.fixed AS part_type_fixed,
    pt.sort_order AS part_type_sort_order
FROM weekly_part wp
JOIN part_type pt ON wp.part_type_id = pt.id
WHERE wp.week_plan_id = ?
ORDER BY wp.sort_order;

insertWeeklyPart:
INSERT INTO weekly_part(id, week_plan_id, part_type_id, sort_order)
VALUES (?, ?, ?, ?);

deleteWeeklyPart:
DELETE FROM weekly_part WHERE id = ?;

deleteAllPartsForWeek:
DELETE FROM weekly_part WHERE week_plan_id = ?;

updateWeeklyPartSortOrder:
UPDATE weekly_part SET sort_order = ? WHERE id = ?;

-- Assignment queries
assignmentsForWeek:
SELECT
    a.id,
    a.weekly_part_id,
    a.person_id,
    a.slot,
    p.first_name,
    p.last_name,
    p.sex,
    p.active
FROM assignment a
JOIN person p ON a.person_id = p.id
JOIN weekly_part wp ON a.weekly_part_id = wp.id
WHERE wp.week_plan_id = ?
ORDER BY wp.sort_order, a.slot;

upsertAssignment:
INSERT INTO assignment(id, weekly_part_id, person_id, slot)
VALUES (?, ?, ?, ?)
ON CONFLICT(weekly_part_id, slot) DO UPDATE SET
    person_id = excluded.person_id;

deleteAssignment:
DELETE FROM assignment WHERE id = ?;

personAlreadyAssignedInWeek:
SELECT COUNT(*) FROM assignment a
JOIN weekly_part wp ON a.weekly_part_id = wp.id
WHERE wp.week_plan_id = ? AND a.person_id = ?;

countAssignmentsForWeek:
SELECT COUNT(*)
FROM assignment a
JOIN weekly_part wp ON a.weekly_part_id = wp.id
WHERE wp.week_plan_id = ?;

countAssignmentsForPerson:
SELECT COUNT(*) FROM assignment WHERE person_id = ?;

deleteAssignmentsForPerson:
DELETE FROM assignment WHERE person_id = ?;

-- Ranking queries (M4)
lastGlobalAssignmentPerPerson:
SELECT
    p.id AS person_id,
    MAX(wpl.week_start_date) AS last_week_date
FROM person p
LEFT JOIN assignment a ON a.person_id = p.id
LEFT JOIN weekly_part wp ON a.weekly_part_id = wp.id
LEFT JOIN week_plan wpl ON wp.week_plan_id = wpl.id
WHERE p.active = 1
GROUP BY p.id;

lastPartTypeAssignmentPerPerson:
SELECT
    p.id AS person_id,
    MAX(wpl.week_start_date) AS last_week_date
FROM person p
LEFT JOIN assignment a ON a.person_id = p.id
LEFT JOIN weekly_part wp ON a.weekly_part_id = wp.id
    AND wp.part_type_id = ?
LEFT JOIN week_plan wpl ON wp.week_plan_id = wpl.id
WHERE p.active = 1
GROUP BY p.id;

lastSlot1GlobalAssignmentPerPerson:
SELECT
    p.id AS person_id,
    MAX(wpl.week_start_date) AS last_week_date
FROM person p
LEFT JOIN assignment a ON a.person_id = p.id AND a.slot = 1
LEFT JOIN weekly_part wp ON a.weekly_part_id = wp.id
LEFT JOIN week_plan wpl ON wp.week_plan_id = wpl.id
WHERE p.active = 1
GROUP BY p.id;

lastSlot1PartTypeAssignmentPerPerson:
SELECT
    p.id AS person_id,
    MAX(wpl.week_start_date) AS last_week_date
FROM person p
LEFT JOIN assignment a ON a.person_id = p.id AND a.slot = 1
LEFT JOIN weekly_part wp ON a.weekly_part_id = wp.id
    AND wp.part_type_id = ?
LEFT JOIN week_plan wpl ON wp.week_plan_id = wpl.id
WHERE p.active = 1
GROUP BY p.id;

-- Diagnostics queries
countWeekPlansBeforeDate:
SELECT COUNT(*)
FROM week_plan
WHERE week_start_date < ?;

countWeeklyPartsBeforeDate:
SELECT COUNT(*)
FROM weekly_part wp
JOIN week_plan wpl ON wp.week_plan_id = wpl.id
WHERE wpl.week_start_date < ?;

countAssignmentsBeforeDate:
SELECT COUNT(*)
FROM assignment a
JOIN weekly_part wp ON a.weekly_part_id = wp.id
JOIN week_plan wpl ON wp.week_plan_id = wpl.id
WHERE wpl.week_start_date < ?;

deleteWeekPlansBeforeDate:
DELETE FROM week_plan
WHERE week_start_date < ?;

-- Monthly programs (new)
listProgramsCurrentAndFuture:
SELECT id, year, month, start_date, end_date, template_applied_at, created_at
FROM program_monthly
WHERE end_date >= ?
ORDER BY start_date;

findProgramByYearMonth:
SELECT id, year, month, start_date, end_date, template_applied_at, created_at
FROM program_monthly
WHERE year = ? AND month = ?;

findProgramById:
SELECT id, year, month, start_date, end_date, template_applied_at, created_at
FROM program_monthly
WHERE id = ?;

insertProgramMonthly:
INSERT INTO program_monthly(id, year, month, start_date, end_date, template_applied_at, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?);

updateProgramTemplateAppliedAt:
UPDATE program_monthly
SET template_applied_at = ?
WHERE id = ?;

deleteProgramMonthly:
DELETE FROM program_monthly
WHERE id = ?;

-- Week plan extended (new)
insertWeekPlanWithProgram:
INSERT INTO week_plan(id, week_start_date, program_id, status)
VALUES (?, ?, ?, ?);

listWeekPlansByProgram:
SELECT id, week_start_date, program_id, status
FROM week_plan
WHERE program_id = ?
ORDER BY week_start_date;

findWeekPlanByDateAndProgram:
SELECT id, week_start_date, program_id, status
FROM week_plan
WHERE week_start_date = ? AND program_id = ?;

updateWeekPlanStatus:
UPDATE week_plan
SET status = ?
WHERE id = ?;

-- Schema templates (new)
deleteAllSchemaWeekParts:
DELETE FROM schema_week_part;

deleteAllSchemaWeeks:
DELETE FROM schema_week;

insertSchemaWeek:
INSERT INTO schema_week(id, week_start_date)
VALUES (?, ?);

insertSchemaWeekPart:
INSERT INTO schema_week_part(id, schema_week_id, part_type_id, sort_order)
VALUES (?, ?, ?, ?);

findSchemaWeekByDate:
SELECT id, week_start_date
FROM schema_week
WHERE week_start_date = ?;

countSchemaWeeks:
SELECT COUNT(*)
FROM schema_week;

schemaPartsByWeek:
SELECT
    swp.id,
    swp.schema_week_id,
    swp.part_type_id,
    swp.sort_order,
    pt.code AS part_type_code,
    pt.label AS part_type_label,
    pt.people_count AS part_type_people_count,
    pt.sex_rule AS part_type_sex_rule,
    pt.fixed AS part_type_fixed,
    pt.sort_order AS part_type_sort_order
FROM schema_week_part swp
JOIN part_type pt ON pt.id = swp.part_type_id
WHERE swp.schema_week_id = ?
ORDER BY swp.sort_order;

-- Part type revisions (new)
findPartTypeById:
SELECT id, code, label, people_count, sex_rule, fixed, active, sort_order, current_revision_id
FROM part_type
WHERE id = ?;

listAllPartTypesExtended:
SELECT id, code, label, people_count, sex_rule, fixed, active, sort_order, current_revision_id
FROM part_type
ORDER BY sort_order, label;

insertPartTypeRevision:
INSERT INTO part_type_revision(
    id,
    part_type_id,
    label,
    people_count,
    sex_rule,
    fixed,
    revision_number,
    created_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?);

latestPartTypeRevisionByPartType:
SELECT id, part_type_id, label, people_count, sex_rule, fixed, revision_number, created_at
FROM part_type_revision
WHERE part_type_id = ?
ORDER BY revision_number DESC
LIMIT 1;

updatePartTypeCurrentRevision:
UPDATE part_type
SET
    current_revision_id = ?,
    label = ?,
    people_count = ?,
    sex_rule = ?,
    fixed = ?,
    active = ?,
    sort_order = ?
WHERE id = ?;

deactivatePartTypesMissingCodes:
UPDATE part_type
SET active = 0
WHERE code NOT IN ?;

deactivateAllPartTypes:
UPDATE part_type
SET active = 0;

-- Eligibility (new)
upsertPersonPartTypeEligibility:
INSERT INTO person_part_type_eligibility(id, person_id, part_type_id, can_lead)
VALUES (?, ?, ?, ?)
ON CONFLICT(person_id, part_type_id) DO UPDATE SET
    can_lead = excluded.can_lead;

eligibilityByPerson:
SELECT id, person_id, part_type_id, can_lead
FROM person_part_type_eligibility
WHERE person_id = ?;

leadEligibilityCandidatesByPartTypes:
SELECT person_id, part_type_id
FROM person_part_type_eligibility
WHERE can_lead = 1
  AND part_type_id IN ?;

deletePersonEligibilityByPartType:
DELETE FROM person_part_type_eligibility
WHERE part_type_id = ?;

deleteLeadEligibilityByPartTypes:
DELETE FROM person_part_type_eligibility
WHERE part_type_id IN ?;

updatePersonSuspended:
UPDATE person
SET suspended = ?
WHERE id = ?;

updatePersonCanAssist:
UPDATE person
SET can_assist = ?
WHERE id = ?;

countFutureAssignmentsForPersonFromDate:
SELECT COUNT(*)
FROM assignment a
JOIN weekly_part wp ON a.weekly_part_id = wp.id
JOIN week_plan wpl ON wp.week_plan_id = wpl.id
WHERE a.person_id = ?
  AND wpl.week_start_date >= ?;

futureAssignmentWeeksForPersonFromDate:
SELECT DISTINCT wpl.week_start_date
FROM assignment a
JOIN weekly_part wp ON a.weekly_part_id = wp.id
JOIN week_plan wpl ON wp.week_plan_id = wpl.id
WHERE a.person_id = ?
  AND wpl.week_start_date >= ?
ORDER BY wpl.week_start_date;

-- Assignment settings (new)
findAssignmentSettings:
SELECT id, strict_cooldown, lead_weight, assist_weight, lead_cooldown_weeks, assist_cooldown_weeks
FROM assignment_settings
LIMIT 1;

upsertAssignmentSettings:
INSERT INTO assignment_settings(
    id,
    strict_cooldown,
    lead_weight,
    assist_weight,
    lead_cooldown_weeks,
    assist_cooldown_weeks
)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    strict_cooldown = excluded.strict_cooldown,
    lead_weight = excluded.lead_weight,
    assist_weight = excluded.assist_weight,
    lead_cooldown_weeks = excluded.lead_cooldown_weeks,
    assist_cooldown_weeks = excluded.assist_cooldown_weeks;

-- Schema anomalies (new)
clearSchemaUpdateAnomalies:
DELETE FROM schema_update_anomaly;

insertSchemaUpdateAnomaly:
INSERT INTO schema_update_anomaly(
    id,
    person_id,
    part_type_id,
    reason,
    schema_version,
    created_at,
    dismissed
)
VALUES (?, ?, ?, ?, ?, ?, ?);

listOpenSchemaUpdateAnomalies:
SELECT id, person_id, part_type_id, reason, schema_version, created_at, dismissed
FROM schema_update_anomaly
WHERE dismissed = 0
ORDER BY created_at DESC;

dismissAllSchemaUpdateAnomalies:
UPDATE schema_update_anomaly
SET dismissed = 1
WHERE dismissed = 0;
